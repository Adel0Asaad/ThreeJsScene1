<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shaders - ocean</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<section id="loading-screen">

			<div id="loader"></div>
		
		</section>

		<div id="container"></div>
		<div id="info">
			
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl ocean
		</div>
		<canvas id="cnvsGradient" width="300" height="50" style="position: absolute; margin: 10px; border: 1px solid aqua"/>

		<script>
			// https://github.com/yiwenl/glsl-fbm/blob/master/3d.glsl
			const fbm = `
			#define NUM_OCTAVES 5
		  
			float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
			vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}
		  
			float noise(vec3 p){
				vec3 a = floor(p);
				vec3 d = p - a;
				d = d * d * (3.0 - 2.0 * d);
		  
				vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
				vec4 k1 = perm(b.xyxy);
				vec4 k2 = perm(k1.xyxy + b.zzww);
		  
				vec4 c = k2 + a.zzzz;
				vec4 k3 = perm(c);
				vec4 k4 = perm(c + 1.0);
		  
				vec4 o1 = fract(k3 * (1.0 / 41.0));
				vec4 o2 = fract(k4 * (1.0 / 41.0));
		  
				vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
				vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
		  
				return o4.y * d.y + o4.x * (1.0 - d.y);
			}
		  
		  
			float fbm(vec3 x) {
			  float v = 0.0;
			  float a = 0.5;
			  vec3 shift = vec3(100);
			  for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			  }
			  return v;
			}
			`;
		  </script>
		<script type="module">
			import * as THREE from '../build/three.module.js';
			import Stats from './jsm/libs/stats.module.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';
			import { DRACOLoader } from './jsm/loaders/DRACOLoader.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { PositionalAudioHelper } from './jsm/helpers/PositionalAudioHelper.js';
			import { Water } from './jsm/objects/Water.js';
			import { Sky } from './jsm/objects/Sky.js';
			//import {Fire} from './jsm/objects/Fire.js'

			let clickFlag = 0;
			let sundownFlag = 0;
			let container, stats;
			let camera, scene, renderer;
			let controls, water, sun, dirLight, light, lightTarget, lightHelper;
			let geom, mat, cone;

			//define objects
			let island, island2;
			let boat, girl, person, flamingo, model, dancingMan, road, road2, road3, road4, rocks, sidewalk, sidewalk2;
			let fence, fence2, roadblock;
			let animCar, beetleCar;
			let field, tallGreenField, dustyPath, billBoard, motelSign, abndBuilding, diner;
			let dinerWall, dinerWall2, dinerWall3, dinerWall4, dinerWall5, dinerWall6, dinerWall6extend, dinerWall6extend2, dinerWall6extend3, dinerWall6extend4, dinerWall7, dinerWall8;
			let gasStation, ground3, rockyGround, dirtyGround, wall, house;
			let coast, lighthouse;
			
			//fire trial
			//let fire, fireTex, wireframeMat, wireframe;

			let visualHelpPlane;
			let coneGrp = new THREE.Group();
			//CLIPPING DEFINE
			let clipMaterial;
			let nzPlane, specialpzPlane, pzPlane, nxPlane, pxPlane, nyPlane, pyPlane;
			let dinerpzPlane, dinernxPlane, dinernzPlane;

			//SHADING DEFINE
			let shadeMaterial;


			//cloudss
			let cloudGroup = new THREE.Group;
	
			let cloudParticles = [];
			//define mixers
			let mixer, mixer1, mixer2, mixer3;

			let switchF = 0;
			let prevTime = Date.now();
			const clock = new THREE.Clock();

			const parameters = {
					elevation: 3,
					azimuth: 180,
					x: 0,
					y: Math.PI/2,
					z: 0, 
					xp: -3400,
					zp: -2360,
					yp: -3,
					pzConstant: -386,
					nxConstant: 3418,
					nzConstant: 2121,
					fog: 1,
				};
			
			//define sound
			let sound, sound1;
			let timeFlag = 0;
			let smokeMaterial, smokeParticles = [];

/* 			textureLoader.crossOrigin = '';

			textureLoader.load(
				'https://s3-us-west-2.amazonaws.com/s.cdpn.io/82015/blue-smoke.png',
				function onLoad(texture) {
					const smokeGeo = new THREE.PlaneBufferGeometry(300, 300);

					smokeMaterial = new THREE.MeshLambertMaterial({
						map: texture,
						transparent: true
					});

					for (let p = 0, l = 100; p < l; p++) {
						let particle = new THREE.Mesh(smokeGeo, smokeMaterial);

						particle.position.set(
							Math.random() * 500 - 250,
							Math.random() * 500 + 4000,
							Math.random() * 1000 - 100
						);

						particle.rotation.z = Math.random() * 360;
						particle.rotation.x = Math
						scene.add(particle);
						smokeParticles.push(particle);
					}
				}
       	 	);

 */

			init();
			animate();

			function toggleFog(){
				if(scene.fog){
					scene.fog = null
				}else{
					scene.fog = new THREE.Fog( 0x77777f, 3500, 4500 );
				}
			}
			function init() {
				
				window.addEventListener('click', onClickaaaa);

				const loadingManager = new THREE.LoadingManager( () => {
	
				const loadingScreen = document.getElementById( 'loading-screen' );
				loadingScreen.classList.add( 'fade-out' );
	
				// optional: remove loader from DOM via event listener
				loadingScreen.addEventListener( 'transitionend', onTransitionEnd );
	
				} );
				
				container = document.getElementById( 'container' );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				// ENABLING CLIPPING FOR RENDERER
				renderer.localClippingEnabled = true;
				document.body.appendChild(renderer.domElement);
			

				//

				scene = new THREE.Scene();
				//scene.fog = new THREE.Fog( 0x77777f, 3500, 4500 );
				
				//scene.background = new THREE.Color( 0x444466 );
				
				//renderer.setClearColor(scene.fog.color);
				camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 1, 20000 );
				camera.position.set( 2000, 900, 2000 );

				//

				sun = new THREE.Vector3();

				// Water

				const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );

				water = new Water(
					waterGeometry,
					{
						textureWidth: 512,
						textureHeight: 512,
						waterNormals: new THREE.TextureLoader().load( 'textures/waternormals.jpg', function ( texture ) {

							texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

						} ),
						sunDirection: new THREE.Vector3(),
						sunColor: 0xffffff,
						waterColor: 0x001e0f,
						distortionScale: 3.7,
						fog: scene.fog !== undefined
					}
				);

				water.rotation.x = - Math.PI / 2;

				scene.add( water );



				//MY TRY AT NOISE CLOUDS

				const cloudGeo = new THREE.SphereGeometry(400, 250, 250);
				
				const cloudMaterial = new THREE.MeshPhongMaterial({
					transparent: true,
					opacity: 0.85,
					color: 0x999999,
				});
				let cloud = new THREE.Mesh(cloudGeo,cloudMaterial);

				// let g = new THREE.SphereGeometry(100, 500, 400);

				// let pos = g.attributes.position;
				// let v = new THREE.Vector3();
				// let axis = new THREE.Vector3(0, 1, 0);
				// for(let i = 0; i < pos.count; i++){
				// v.fromBufferAttribute(pos, i);
				// let ratio = (v.y - (-2.5)) / 5;
				// v.applyAxisAngle(axis, THREE.MathUtils.degToRad(60) * ratio);
				// pos.setXYZ(i, v.x, v.y, v.z);
				// }
				// g.computeVertexNormals();

				// let uniforms = {
				// tex: {
				// 	value: setGradient()
				// }
				// }
				// let m = new THREE.MeshStandardMaterial({
				// metalness: 0.1,
				// roughness: 0.75,
				// onBeforeCompile: shader => {
				// 	shader.uniforms.tex = uniforms.tex;
				// 	shader.vertexShader = `
				// 	varying vec3 vPos;
				// 	${shader.vertexShader}
				// 	`.replace(
				// 	`#include <begin_vertex>`,
				// 	`#include <begin_vertex>
				// 	//vPos = (modelMatrix * vec4(position, 1.0)).xyz;
				// 	vPos = vec3(position);
				// 	`
				// 	);
				// 	//console.log(shader.vertexShader);
				// 	shader.fragmentShader = `
				// 	uniform sampler2D tex;
				// 	varying vec3 vPos;
				// 	${fbm}
				// 	${shader.fragmentShader}      
				// 	`.replace(
				// 	`vec4 diffuseColor = vec4( diffuse, opacity );`,
				// 	`
				// 	float d = fbm(vPos * 0.5);
				// 	for(int i = 0; i < 4; i++){
				// 		d = fbm(vPos * (float(i) + 1.) * d);
				// 	}

				// 	vec3 col = texture(tex, vec2(d, 0.5)).rgb;
				// 	vec4 diffuseColor = vec4( col, opacity );`
				// 	);
				// 	//console.log(shader.fragmentShader);
				// }
				// });
				
				// let o = new THREE.Mesh(g, m);
			 	let xpos = -4000;
				let zpos = -4000;
				let ypos = 4000;
				for(var oxpos = -4000; oxpos< 4000; oxpos+= (2200 + 600*Math.random())){
					for(var ozpos = -4000; ozpos < 4000; ozpos += (2700 + 600*Math.random())){
						for (var i = 0; i < 6; i++){
							// sgrps[i] = cloud.clone();
							// sgrps[i].position.x = xpos;
							// sgrps[i].position.z = zpos;
							// sgrps[i].position.y = ypos;
							// cloudGroup.add(sgrps[i]);
							console.log("hi");

							ypos = 3800 + (400*Math.random());
							for (var j = 0; j < 8; j++){
								let tempCloud = cloud.clone();
								tempCloud.position.x = xpos;
								tempCloud.position.z = zpos;
								tempCloud.position.y = ypos;
								if(Math.random() > 0.45)
									cloudGroup.add(tempCloud);
								
								console.log("hii");

								// for(var k = 0; k < 2; k++){
									
								// 	ypos+= 300;
								// 	let tempCloud = o.clone();
								// 	tempCloud.position.x = xpos;
								// 	tempCloud.position.z = zpos;
								// 	tempCloud.position.y = ypos;
								// 	if(Math.random() > 0.7)
								// 		cloudGroup.add(tempCloud);
								// 	console.log("hii");
									
								// }
								
								zpos+= 300;
							} 
							zpos = ozpos;
							xpos += 300 ;
						}
						xpos = oxpos; 
					}
				}
				scene.add(cloudGroup);


				// scene.add(o);


				//MY TRY AT NOISE CLOUDS

				// Skybox

				const sky = new Sky();
				sky.scale.setScalar( 10000 );
				scene.add( sky );

				const skyUniforms = sky.material.uniforms;

				skyUniforms[ 'turbidity' ].value = 10;
				skyUniforms[ 'rayleigh' ].value = 1.5;
				skyUniforms[ 'mieCoefficient' ].value = 0.005;
				skyUniforms[ 'mieDirectionalG' ].value = 0.8;
				
				//light house light
	 			light = new THREE.SpotLight(0xffff00, 10, 0, 0.2, 1);
				light.position.set (3493, 350, -588);
				light.castShadow = true; 
				light.shadowMapVisible = true;
				
				lightTarget = new THREE.Object3D()
				lightTarget.position.set(1000, 0, -200)
				scene.add(lightTarget)
				light.target = lightTarget
				scene.add(light);

				lightHelper = new THREE.SpotLightHelper( light, 0xffffff );
				scene.add( lightHelper );

				//PAIN

				geom = new THREE.ConeGeometry( 5, 40, 32 );
				
				mat = new THREE.MeshBasicMaterial( {color: 0xffff00, opacity: 0.5, visible: true} );
				cone = new THREE.Mesh( geom, mat );
				
				cone.rotation.z = -Math.PI/2;
				// cone.rotation.y = Math.PI/2;
				// cone.position.y = 500;
				cone.scale.set (20, 20, 20);
				cone.position.x -= 400;
				// cone.position.x += 20*20;
			
				//cone.rotation.z = 4.60766922526503;
				//cone.rotation.z = Math.PI/2;
				// focus on the tip
				coneGrp.add(cone);
				// coneGrp.rotation.y = Math.PI/2;
				coneGrp.position.set (3491, 347, -588);
				coneGrp.rotation.y = 6.03;
				coneGrp.rotation.z = 0.05;
				// coneGrp.position.set (3893, 348, -193);
				// coneGrp.position.set (0, 500, 0);
				scene.add(coneGrp)

				// add directional light to scene
				dirLight = new THREE.DirectionalLight( 0xffffff, 2 );
		
				dirLight.position.set( - 12, 1809, 1 );
				scene.add( dirLight );
				dirLight.target.position.set(0, 1809, 0);
				scene.add(dirLight.target);

				dirLight.castShadow = true;

				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;

				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

				const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
				scene.add( dirLightHelper );

				// add ambient light to scene
				let ambLighting = new THREE.AmbientLight(0xFFFFFF, 0.5 );
				scene.add(ambLighting); 

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				
				function removeClouds(){
					scene.remove(cloudGroup)
				}
				function enableClouds(){
					scene.add(cloudGroup)
				}

				function updateSun() {

					const phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );
					const theta = THREE.MathUtils.degToRad( parameters.azimuth );
					if (parameters.elevation < 3.5 && sundownFlag == 0){
						sundownFlag = 1
						removeClouds()
					}else if(parameters.elevation > 3.5 && sundownFlag == 1){
						sundownFlag = 0
						enableClouds()
					}

					sun.setFromSphericalCoords( 1, phi, theta );

					sky.material.uniforms[ 'sunPosition' ].value.copy( sun );
					water.material.uniforms[ 'sunDirection' ].value.copy( sun ).normalize();
					const radius = 5000;
					const sinPhiRadius = Math.sin( phi ) * radius;

					let lightX = sinPhiRadius * Math.sin( theta );
					let lightY = Math.cos( phi ) * radius;
					let lightZ = sinPhiRadius * Math.cos( theta ); 

					dirLight.position.set ( lightX, lightY, lightZ);

					scene.environment = pmremGenerator.fromScene( sky ).texture;
					
				}

				updateSun();
				
				// intiate loaders
				const gltfLoader = new GLTFLoader(loadingManager);
				const fbxLoader = new FBXLoader(loadingManager);
				const dracoLoader = new DRACOLoader(loadingManager);
				const textureLoader = new THREE.TextureLoader(loadingManager);
				dracoLoader.setDecoderPath( 'js/libs/draco/gltf/' );
				textureLoader.crossOrigin = '';

				//
				const audioLoader = new THREE.AudioLoader();
				const listener = new THREE.AudioListener();
				camera.add( listener );

				sound = new THREE.PositionalAudio(listener);
				sound1 = new THREE.PositionalAudio(listener);

				audioLoader.load(('sounds/rickroll.mp3'), function (buffer) {
				sound.setBuffer( buffer );
				sound.setRefDistance( 150 );
				sound.setLoop( true );
				sound.setVolume( 0.1 );


				});

				audioLoader.load(('sounds/flamingo.mp3'), function (buffer) {
				sound1.setBuffer( buffer );
				sound1.setRefDistance( 150 );
				sound1.setLoop( true );
				sound1.setVolume( 0.9 );


				});
				
				//TESTING CLIPPING
				nzPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 5000 );
				pzPlane = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 5000 );
				specialpzPlane = new THREE.Plane( new THREE.Vector3(0, 0, -1), 5000+15);
				nxPlane = new THREE.Plane( new THREE.Vector3( 1, 0, 0 ), 5000 );
				pxPlane = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), 5000 );

				clipMaterial = new THREE.MeshNormalMaterial({
					clippingPlanes: [pzPlane, nzPlane, pxPlane, nzPlane],
					clipShadows: true,
					side: THREE.DoubleSide
				})

				const roadGroup = new THREE.Group();
				const roadGroup2 = new THREE.Group();
				// const cloudGroup = new THREE.Group();

				// add road
				gltfLoader.load( 'models/gltf/road/scene.gltf', 
				function ( gltf ) {
				road = gltf.scene;
				road.scale.set(20, 20, 54);
				
				road.traverse( function ( child ) {
				if ( child.isMesh ) {

					child.castShadow = true;
					child.receiveShadow = true;
					
					child.material.clippingPlanes = [ pzPlane, specialpzPlane, pxPlane, nzPlane ],
					child.material.clipShadows = true,
					child.material.side = THREE.DoubleSide
				}
				});

				road2 = road.clone();
				road2.position.x += 120;

				roadGroup.add(road);
				roadGroup.add(road2)
				roadGroup.position.set(-1070-120, 190-13, -5000);

			 	let sgrps = [];
				let crntpos = roadGroup.position.z;
				for (var i = 0; i < 16; i++){
 			 		sgrps[i] = roadGroup.clone();
  					sgrps[i].position.z = crntpos;
  					scene.add(sgrps[i]);
					crntpos += 650-3;
				}  

				}, undefined, function ( error ) {

				console.error( error );
				} );


				// add horizontal road
				gltfLoader.load( 'models/gltf/road/scene.gltf', 
				function ( gltf ) {
				road3 = gltf.scene;
				road3.scale.set(20, 20, 54);
				road3.rotation.y = Math.PI/2;
				
				road3.traverse( function ( child ) {
				if ( child.isMesh ) {

					child.castShadow = true;
					child.receiveShadow = true;		
					child.material.clippingPlanes = [ pzPlane, specialpzPlane, nxPlane, nzPlane ],
					child.material.clipShadows = true,
					child.material.side = THREE.DoubleSide
				}
				});

				road4 = road3.clone();
				road4.position.z += 120;

				roadGroup2.add(road3);
				roadGroup2.add(road4)
				roadGroup2.position.set (-5000, 175, -2300);
				
			 	let sgrps = [];
				let crntpos = roadGroup2.position.x;
				for (var i = 0; i < 7; i++){
 			 		sgrps[i] = roadGroup2.clone();
  					sgrps[i].position.x = crntpos;
  					scene.add(sgrps[i]);
					crntpos += 650-3;
				}  

				}, undefined, function ( error ) {

				console.error( error );
				} );

				// //Load fire
				// fireTex = textureLoader.load ("textures/Fire.png");

				// wireframeMat = new THREE.MeshBasicMaterial({
				// 	color : new THREE.Color(0xffffff),
				// 	wireframe : true
				// });

				// fire = new Fire(fireTex);

				// wireframe = new THREE.Mesh(fire.geometry, wireframeMat.clone());
				// fire.add(wireframe);
				// wireframe.visible = true;
				// wireframe.visible = false;

				// fire.position.set ( 100, 1000, 100);
				// scene.add (fire);

				
				//Load static beetle car
				gltfLoader.setDRACOLoader (dracoLoader);
				gltfLoader.load( 'models/gltf/beetlecar/scene.gltf', function ( gltf ) {
				beetleCar = gltf.scene;
				beetleCar.position.set (-1570, 165, -3167);
				beetleCar.scale.set (0.5, 0.5, 0.5);
				beetleCar.rotation.y = Math.PI/1.5;
				scene.add( beetleCar );
				beetleCar.add(sound);
				}, undefined, function ( error ) {

				console.error( error );

				} ); 
				
 				//Load moving car
				gltfLoader.load( "models/gltf/animcar/scene.gltf", function ( gltf ) {
				animCar = gltf.scene;
				animCar = gltf.scene.children[ 0 ];
				animCar.scale.set( 0.3, 0.3, 0.3 );
				animCar.position.set (-1190, 180, -5000);
				animCar.rotation.x = 4.694
				
				animCar.traverse( function ( child ) {
				if ( child.isMesh ) {

					child.castShadow = true;
					child.receiveShadow = true;
					
					child.material.clippingPlanes = [ pzPlane, pzPlane, pxPlane, nzPlane ],
					child.material.clipShadows = true,
					child.material.side = THREE.DoubleSide
					}
				});

				scene.add( animCar );
				mixer3 = new THREE.AnimationMixer( animCar );
				mixer3.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();

				} ); 

				//Load dusty path
				gltfLoader.load( "models/gltf/dusty_path_in_the_fields/scene.gltf", function ( gltf ) {
				dustyPath = gltf.scene;
				dustyPath.scale.set( 0.5, 0.5, 0.5 );
				dustyPath.position.set (-1938+135, 180, -341-260);
				scene.add( dustyPath );

				var dustyPath2 = dustyPath.clone();
				dustyPath2.position.set(-1938+135, 180, -2100-260);
				dustyPath2.scale.set(dustyPath2.scale.x*1, dustyPath2.scale.y*1, dustyPath2.scale.z*-1);
				scene.add(dustyPath2);
				} );

				//Load truck billboard
				gltfLoader.load( "models/gltf/billboard_post_apo/scene.gltf", function ( gltf ) {
				billBoard = gltf.scene;
				billBoard.scale.set( 0.8, 0.8, 0.8 );
				billBoard.rotation.y = 1.53588974175501;
				billBoard.position.set (-1500, 167, -1324);
				scene.add( billBoard );
				} );


				//Load motel sign
				gltfLoader.load( "models/gltf/motelsign_post_apo/scene.gltf", function ( gltf ) {
				motelSign = gltf.scene;
				motelSign.scale.set( 0.2, 0.2, 0.2);
				motelSign.rotation.y = 0.837758040957278;
				motelSign.position.set (-2307+195, 140, 400-260);
				scene.add( motelSign );
				} );

				//Load abndoned building 
				gltfLoader.load( "models/gltf/abandon_building/scene.gltf", function ( gltf ) {
				abndBuilding = gltf.scene;
				abndBuilding.scale.set( 0.2, 0.2, 0.2 );
				abndBuilding.rotation.y = 3.15904594610974;
				abndBuilding.position.set (-2430+195, 151, 0-260);
				scene.add( abndBuilding );
				} );

				//Load lighhouse 
				gltfLoader.load( "models/gltf/grebeni/scene.gltf", function ( gltf ) {
				lighthouse = gltf.scene;
				lighthouse.scale.set( 1600, 1600, 1600);
				lighthouse.rotation.y = 1.0471975511966;
				lighthouse.position.set (3903, 666, -521);
				scene.add( lighthouse );
				} );
				
				//TESTING CLIPPING
				dinerpzPlane = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), -386 );
				dinernxPlane = new THREE.Plane( new THREE.Vector3( 1, 0, 0  ), 3418 );
				dinernzPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1  ), 2121 );

				//Load diner
				gltfLoader.load( "models/gltf/restro/scene.gltf", function ( gltf ) {
				diner = gltf.scene;
				diner.scale.set( 0.9, 0.9, 0.9 );
				diner.rotation.y = 1.56;
				diner.position.set (-2250, 151, -95);
				diner.traverse( function ( child ) {
					if ( child.isMesh ) {

						child.castShadow = true;
						child.receiveShadow = true;
						child.material.clippingPlanes = [ dinerpzPlane, dinernxPlane, dinernzPlane ],
						child.material.opacity = 1;
						child.material.side = THREE.DoubleSide

					}
			
				});
				scene.add( diner );

				} );

				//Load gas station
				gltfLoader.load( "models/gltf/gas_station_ussr/scene.gltf", function ( gltf ) {
				gasStation = gltf.scene;
				gasStation.scale.set( 7, 7, 7 );
				gasStation.rotation.y = 3.15904594610974;
				gasStation.position.set (-2184, 268, -3044);
				scene.add( gasStation );

				} );

				// new THREE.Plane( new THREE.Vector3( 1, 0, 0  ), 3570 )

				//Load walls to surround diner/abandoned building/gas station
				gltfLoader.load( "models/gltf/mossy_stone_wall/scene.gltf", function ( gltf ) {
						dinerWall = gltf.scene;
						dinerWall.scale.set( 1.7, 1.7, 1.7 );
						dinerWall.traverse( function ( child ) {
							if ( child.isMesh ) {

								child.castShadow = true;
								child.receiveShadow = true;
								
								child.material.clippingPlanes = [ pzPlane, specialpzPlane, pxPlane, nzPlane ],
								child.material.clipShadows = true,
								child.material.side = THREE.DoubleSide

							}
						
						
					});
						dinerWall.position.set(-2189, -3, 520);
						dinerWall2 = dinerWall.clone();
						dinerWall2.rotation.y = Math.PI/2;
						dinerWall2.position.set(-2460, -3, 28);

						dinerWall4 = dinerWall.clone();
						dinerWall4.rotation.y = Math.PI/2;
						dinerWall4.position.set(-3420, -3, -900+140)

						dinerWall5 = dinerWall4.clone();
						dinerWall5.position.z = -1210;
						dinerWall5.traverse( function ( child ) {
							if ( child.isMesh ) {

								child.castShadow = true;
								child.receiveShadow = true;
								
								child.material.clippingPlanes = [ dinernzPlane,  pzPlane, specialpzPlane, pxPlane, nzPlane ],
								child.material.clipShadows = true,
								child.material.side = THREE.DoubleSide

							}

							});

						

						
						scene.add(dinerWall);
						scene.add(dinerWall2);
						scene.add(dinerWall4);
						scene.add(dinerWall5);
						
						
						//x1= -2189, z1= 520,
						//2
						// 1.57079632679
						// rotation.y = Math.PI/2, x2 = -2530, z2 = 540, y =28 
						//3
						// x= -3460, z= -250
						//4
						// 1.57079632679
						// x= -3420, z= -900
						//5
						// GNB KOSOMO z = -1680
						//6
						//x= -3460, z = -2500
						//7
						// 1.57079632679
						//x= -2530, z= -2600
						//8
						//x= -2189, z= -3450
				});
				//This is a speshal wall...
				gltfLoader.load( "models/gltf/mossy_stone_wall/scene.gltf", function ( gltf ) {
					dinerWall3 = gltf.scene;
				dinerWall3.scale.set( 1.7, 1.7, 1.7 );
				dinerWall3.position.set(-3460, -3, -250);
				dinerWall3.traverse( function ( child ) {
					if ( child.isMesh ) {

						child.castShadow = true;
						child.receiveShadow = true;
						
						child.material.clippingPlanes = [  new THREE.Plane( new THREE.Vector3( 1, 0, 0  ), 3520 ) ],
						child.material.clipShadows = true,
						child.material.side = THREE.DoubleSide

					}
			
				});
				scene.add(dinerWall3)
				}, undefined, function ( error ) {

				console.error( error );
				} );

				//Load walls to surround diner/abandoned building/gas station
				gltfLoader.load( "models/gltf/mossy_stone_wall/scene.gltf", function ( gltf ) {
						dinerWall6 = gltf.scene;
						dinerWall6.scale.set( 1.7, 1.7, 1.7 );
						dinerWall6.traverse( function ( child ) {
							if ( child.isMesh ) {

								child.castShadow = true;
								child.receiveShadow = true;
								
								child.material.clippingPlanes = [ pzPlane, specialpzPlane, nxPlane, nzPlane, pxPlane ],
								child.material.clipShadows = true,
								child.material.side = THREE.DoubleSide

							}
						
						dinerWall6.position.set(-3400, -3, -2360)
						dinerWall6extend = dinerWall6.clone()
						dinerWall6extend.position.x -= 660;
						dinerWall6extend2 = dinerWall6extend.clone()
						dinerWall6extend2.position.x -= 660;

						dinerWall6extend3 = dinerWall6extend.clone()
						dinerWall6extend3.position.z += 367;
						dinerWall6extend4 = dinerWall6extend2.clone()
						dinerWall6extend4.position.z += 367;
						
						

						dinerWall7 = dinerWall6.clone();
						dinerWall7.rotation.y = Math.PI/2;
						dinerWall7.position.set(-2530, -3, -2600)

						dinerWall8 = dinerWall6.clone();
						dinerWall8.position.set(-2189, -3, -3450)
					});
					scene.add(dinerWall6);
					scene.add(dinerWall6extend);
					scene.add(dinerWall6extend2);
					scene.add(dinerWall6extend3);
					scene.add(dinerWall6extend4);
					scene.add(dinerWall7);
					scene.add(dinerWall8);
				});

				//Load coast 
				gltfLoader.load( "models/gltf/coast/scene.gltf", function ( gltf ) {
				coast = gltf.scene;
				coast.scale.set( 10, 10, 10 );
				coast.position.set (0, -200, -3350);
				coast.rotation.set(Math.PI + 0.02, Math.PI/2 - 0.5, Math.PI);
				scene.add( coast );

				const coastClip = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), 80 );
				coast.traverse( function ( child ) {
				if ( child.isMesh ) {

					child.castShadow = true;
					child.receiveShadow = true;
					
					child.material.clippingPlanes = [ coastClip, nzPlane ],
					child.material.clipShadows = true,
					child.material.side = THREE.DoubleSide

				}

				});
				var coast2 = coast.clone();
				coast2.position.set(132, coast.position.y - 30, coast.position.z + 2550 );
				coast2.scale.set (coast2.scale.x * -1, coast2.scale.y * 1, coast2.scale.z*1);
				coast2.rotation.set(0, 1.17, 0);
				scene.add(coast2);

				}, undefined, function ( error ) {

				console.error( error );
				} );

				//Load wall 
				gltfLoader.load( "models/gltf/mossy_stone_wall/scene.gltf", function ( gltf ) {
				wall = gltf.scene;
				wall.scale.set( 1.7, 1.7, 1.7 );
				wall.rotation.set(0, Math.PI/2, 0);
				wall.traverse( function ( child ) {
					if ( child.isMesh ) {

						child.castShadow = true;
						child.receiveShadow = true;
						
						child.material.clippingPlanes = [ pzPlane, specialpzPlane, pxPlane, nzPlane ],
						child.material.clipShadows = true,
						child.material.side = THREE.DoubleSide

					}
				wall.position.set(-882, -3, 160);
				});

			 	let sgrps = [];
				let crntpos = 5000;
				for (var i = 0; i < 16*2; i++){
					sgrps[i] = wall.clone();
					sgrps[i].position.z = crntpos;
					if(i % 2 == 1){
  						crntpos -= 660;
						scene.add(sgrps[i]);
					}else{	
						sgrps[i].position.x -= 367;
						if(i > 6*2 && i < 13*2){

						}else{
							scene.add(sgrps[i]);
						}
					}
					
					}  

				}, undefined, function ( error ) {

				console.error( error );
				} );

				//clouds

				// textureLoader.load("textures/smoke-1.png", function(texture){
				// texture.wrapS = THREE.MirroredRepeatWrapping;
				// texture.wrapT = THREE.MirroredRepeatWrapping;
				// texture.repeat.set( 1, 1);

				// const cloudGeo = new THREE.SphereGeometry(250, 250, 250);
				
				// const cloudMaterial = new THREE.MeshPhongMaterial({
				// 	transparent: false,
				// 	opacity: 1,
				// 	color: 'white',
				// });
				// let cloud = new THREE.Mesh(cloudGeo,cloudMaterial);

				textureLoader.load("textures/smoke-1.png", function(texture){
					const smokeCloudGeo = new THREE.PlaneBufferGeometry(500,500);
					const smokeCloudMaterial = new THREE.MeshLambertMaterial({
						map: texture,
						transparent: true
					});

					for (let p = 0; p < 50; ++p) {
					
					let smokeCloud = new THREE.Mesh(smokeCloudGeo, cloudMaterial);
					smokeCloud.position.set(
						Math.random() * 800 - 400,
						500,
						Math.random() * 500 - 500
					);
					smokeCloud.rotation.x = 1.16;
					smokeCloud.rotation.y = -0.12;
					smokeCloud.rotation.z = Math.random() * 2 * Math.PI;
					smokeCloud.material.opacity = 0.55;
					cloudParticles.push(smokeCloud);
					scene.add(smokeCloud);
					}
				});

				cloud.position.y = 4000;

				let sgrps = [];
				// let xpos = 0;
				// let zpos = 300;
				// let ypos = 4000;
				// for (var i = 0; i < 6; i++){
 			 	// 	// sgrps[i] = cloud.clone();
				// 	// sgrps[i].position.x = xpos;
				// 	// sgrps[i].position.z = zpos;
				// 	// sgrps[i].position.y = ypos;
  				// 	// cloudGroup.add(sgrps[i]);
				// 	console.log("hi");


				// 	for (var j = 0; j < 8; j++){
				// 		let tempCloud = cloud.clone();
				// 		tempCloud.position.x = xpos;
				// 		tempCloud.position.z = zpos;
				// 		tempCloud.position.y = ypos;
				// 		if(Math.random() > 0.45)
				// 			cloudGroup.add(tempCloud);
						
				// 		console.log("hii");

				// 		for(var k = 0; k < 2; k++){
							
				// 			ypos+= 300;
				// 			let tempCloud = cloud.clone();
				// 			tempCloud.position.x = xpos;
				// 			tempCloud.position.z = zpos;
				// 			tempCloud.position.y = ypos;
				// 			if(Math.random() > 0.7)
				// 				cloudGroup.add(tempCloud);
				// 			console.log("hii");
							
				// 		}
				// 		ypos = 4000;
				// 		zpos+= 300;
				// 	} 
				// 	zpos = 300;
				// 	xpos += 300 ;
				// } 
				// scene.add(cloudGroup);

				// for(let p=0; p<20; p++) {
				// //	let cloud = new THREE.Mesh(cloudGeo,cloudMaterial);
				// 	//cloud.position.set(Math.random(), 4000, Math.random() );
				// 	cloudGroup.position.set(
				// 	Math.random()*10000 -5000,
				// 	4000,
				// 	Math.random()*10000 - 5000
				// 	);
				// 	//cloud.scale.set(Math.random()*5, Math.random()*5, Math.random()*5);

				// 	cloudGroup.rotation.x = Math.PI/2;
				// 	// cloud.rotation.y = -0.12;
				// 	// cloud.rotation.z = Math.random()*360;
				// 	//cloud.material.opacity = 0.6;
				
				// 	cloudParticles.push(cloud);
				// }
				// });

 				// load the driving man model
			 	fbxLoader.load( 'models/fbx/Salsa Dancing.fbx', function ( object ) {
				dancingMan = object;
				dancingMan.position.set (-1750, 160, -3200);
				dancingMan.scale.set (0.5, 0.5, 0.5);
				dancingMan.rotation.set(0, Math.PI/2, 0);


				mixer = new THREE.AnimationMixer( dancingMan );

				const action = mixer.clipAction( dancingMan.animations[ 0 ] );
				action.play();

				shadeMaterial = new THREE.MeshNormalMaterial({
					side: THREE.DoubleSide
				})
				dancingMan.traverse( function ( child ) {

					if ( child.isMesh ) {

						child.castShadow = true;
						child.receiveShadow = true;
						console.log("I'm in your childe");
						child.material.metalness = 0;
						child.material.side = THREE.DoubleSide;
						child.material.castShadow = true;

					}
				} );
					
					scene.add( dancingMan );
				} );  
		
 				//Load Boat
				gltfLoader.load( 'models/gltf/boat.glb', function ( gltf ) {
				boat = gltf.scene;
				boat.position.set(-95, 0, -218);
				boat.rotation.set(0.226892802759263, 0.767944870877505,0 );
				scene.add( boat );

				}, undefined, function ( error ) {

				console.error( error );

				} ); 
 
				//Load Flamingo
 				gltfLoader.load( "models/gltf/Flamingo.glb", function ( gltf ) {
				flamingo = gltf.scene;
				flamingo = gltf.scene.children[ 0 ];
				flamingo.scale.set( 0.7, 0.7, 0.7 );

				scene.add( flamingo );
				flamingo.add(sound1);

				mixer1 = new THREE.AnimationMixer( flamingo );
				mixer1.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();

				} );   

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.target.set( 0, 500, 0 );
				controls.minDistance = 40.0;
				controls.maxDistance = 10000.0;
				controls.update();

				//

				const axesHelper = new THREE.AxesHelper(1000)
				axesHelper.position.y = 100;
            	scene.add(axesHelper)
				
				//

				stats = new Stats();
				container.appendChild( stats.dom );

				// GUI

				const gui = new GUI();

				const folderSky = gui.addFolder( 'Sky' );
				folderSky.add( parameters, 'elevation', 0, 90, 0.1 ).onChange( updateSun );
				folderSky.add( parameters, 'azimuth', - 180, 180, 0.1 ).onChange( updateSun );
				folderSky.add( parameters, 'fog', 0, 1, 1).onChange(toggleFog);
				folderSky.open();

				const folderIsland = gui.addFolder ('boat');
				folderIsland.add( parameters, 'x', 0, 2 * Math.PI, Math.PI/180 );
				folderIsland.add( parameters, 'y', 0, 2 * Math.PI, Math.PI/180 );
				folderIsland.add( parameters, 'z', 0, 2 * Math.PI, Math.PI/180  );

				folderIsland.add( parameters, 'xp', -5000, 5000, 1 );
				folderIsland.add( parameters, 'zp', -5000, 5000, 1  );
				folderIsland.add( parameters, 'yp', -5000, 5000, 1  );
				folderIsland.open();

				const folderPlane = gui.addFolder( 'Plane' );
				folderPlane.add( parameters, 'pzConstant', -2000, 2000, 1);
				folderPlane.add( parameters, 'nxConstant', -5000, 5000, 1);
				folderPlane.add( parameters, 'nzConstant', -5000, 5000, 1);
				folderPlane.open();

				const waterUniforms = water.material.uniforms;

				const folderWater = gui.addFolder( 'Water' );
				folderWater.add( waterUniforms.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );
				folderWater.add( waterUniforms.size, 'value', 0.1, 10, 0.1 ).name( 'size' );
				folderWater.open();

				//

				window.addEventListener( 'resize', onWindowResize );
				
			}

			function onTransitionEnd( event ) {
				event.target.remove();
	
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				
				requestAnimationFrame( animate );
				lightHelper.update();
				coneGrp.rotation.y = 6.03;
				coneGrp.rotation.z = 0.05;
				coneGrp.lookAt(parameters.xp, parameters.yp, parameters.zp);


				var delta = clock.getDelta();
				if ( mixer ) mixer.update( delta  );
				if ( mixer1 ) mixer1.update( delta );
				if ( mixer2 ) mixer2.update( delta );
				if ( mixer3 ) mixer3.update( delta );

				// cloudParticles.forEach(p => {
				// 	p.rotation.z -=0.001;
				// 	p.rotation.y -=0.002;
				// 	p.rotation.x -=0.003;
				// });

				render(parameters);
				stats.update();
			}

			function onClickaaaa(){
				
				if (clickFlag == 0){
					clickFlag = 1;				
					console.log("click!");			
					sound.context.resume();
					sound1.context.resume();
				}
				
			}
			//GRADIENT FOR NOISE CLOUDS
			function setGradient(){
  
			let canvas = document.getElementById('cnvsGradient');
			let ctx = canvas.getContext('2d');

			let gradient = ctx.createLinearGradient(0, 0, 300, 0);

			gradient.addColorStop(0.15, 'white');
			gradient.addColorStop(0.5, 'grey');
			gradient.addColorStop(0.85, 'white');

			ctx.fillStyle = gradient;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			return new THREE.CanvasTexture(canvas);

			}

			function render(parameters) {
				const time = performance.now() * 0.001;

				if (time < 20 && time > 19){
					// scene.remove(cloudGroup)
				}
 	 			// coneGrp.rotation.x = parameters.x;
				// coneGrp.rotation.y = parameters.y;
				// coneGrp.rotation.z = parameters.z;
				lightTarget.position.x = parameters.xp;
				lightTarget.position.z = parameters.zp;  
				lightTarget.position.y = parameters.yp; 

				// coneGrp.position.x = parameters.xp;
				// coneGrp.position.z = parameters.zp;  
				// coneGrp.position.y = parameters.yp; 
				// console.log(cone.position.x, cone.position.y, cone.position.z);
				// cone.rotateOnAxis(time);
				

				//lightTarget.position.set (Math.sin(time) * 640 + 1000, Math.sin( time ) * 40, Math.cos(time) * 465 -200);

				
				// dinerpzPlane.constant = parameters.pzConstant;
				// dinernxPlane.constant = parameters.nxConstant;
				// dinernzPlane.constant = parameters.nzConstant;
				//	localPlane.constant = parameters.planeConstant;

				if ( time > 5 && timeFlag == 0){
					sound.play();
					sound1.play();
					timeFlag++;
				}
				animCar.position.z += 10;
				if (animCar.position.z > 7000){
					animCar.position.z = -5000;
				}

				water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
 
 				flamingo.rotation.y = time - 4.5;
				flamingo.position.x = Math.sin(time) * 640;
				flamingo.position.y = Math.sin( time ) * 40 + 888 ;
				flamingo.position.z = Math.cos(time) * 465 -1078; 

				renderer.render( scene, camera );

			}
		</script>

		<script src="https://unpkg.com/three@0.129.0/build/three.js"></script>
		<script src="https://unpkg.com/three@0.129.0/examples/js/controls/OrbitControls.js"></script>
		<script>
			  let simpleNoise = `
			float N (vec2 st) { // https://thebookofshaders.com/10/
				return fract( sin( dot( st.xy, vec2(12.9898,78.233 ) ) ) *  43758.5453123);
			}
			
			float smoothNoise( vec2 ip ){ // https://www.youtube.com/watch?v=zXsWftRdsvU
				vec2 lv = fract( ip );
			  vec2 id = floor( ip );
			  
			  lv = lv * lv * ( 3. - 2. * lv );
			  
			  float bl = N( id );
			  float br = N( id + vec2( 1, 0 ));
			  float b = mix( bl, br, lv.x );
			  
			  float tl = N( id + vec2( 0, 1 ));
			  float tr = N( id + vec2( 1, 1 ));
			  float t = mix( tl, tr, lv.x );
			  
			  return mix( b, t, lv.y );
			}
		  `;
		</script>
	</body>
</html>
